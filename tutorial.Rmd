---
title: "QuIBL analysis tutorial"
author: "Nate Edelman"
date: "3/02/2020"
output:
  html_document: default
  pdf_document: default
---

```{r global_options, message=FALSE, warning=FALSE, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8, echo=TRUE, warning=FALSE)
```

This is a tutorial for how to analyze output from the Quantifying Introgression via Branch Lengths software. For more details on QuIBL see <http://github.com/michaelmiyagi/QuIBL>. To run this tutorial, you will need to have cloned QuIBL and quiblR from github, and intalled their dependencies.

To run QuIBL with a sample dataset, navigate to the directory where quiblR is cloned. We'll start with the data in tutorial/intro_sim_example

```{bash, eval = FALSE}
cd "/Users/nbedelman/Dropbox/quiblR/"
cd tutorial/intro_sim_example
```

Open the file "sampleInputFile.txt" in your text editor of choice

We can see that QuIBL is very simple to run; all we need is a file that has a list of gene trees (one per line), and a taxon that we can use to root the trees ("totalOutgroup"). The rest of the parameters are described at <http://github.com/michaelmiyagi/QuIBL>, but we don't need to mess with them now. To run QuIBL, supply whatever output name you'd like as the "OutputPath", then return to terminal. From the tutorial/intro_sim_example directory, run

```{bash run QuILB, eval = FALSE}
#python <path_to_QuIBL>/QuIBL.py sampleInputFile.txt  
```

This will take a while, so feel free to run it, but we've also supplied the output here, so you can continue with the tutorial while you wait. Everything that follows should be run in R

## Output Data Analysis

First, we'll set up our environment.
```{r load packages}
suppressMessages(library("quiblR"))
suppressMessages(library("ggplot2"))
suppressMessages(library("ape"))
suppressMessages(library("hash"))
suppressMessages(library("ggtree"))
suppressMessages(library("ggpubr"))
suppressMessages(library("dplyr"))

```

## Load the data

Now, we'll import the data generated by our 4-taxon QuIBL run from simulated data.
The important parameters here are:
- We simulated 20% introgression fraction from species 3 into species 2, forward in time
- Each population is comprised of 1 million individuals, the introgression time between 3 and 2 is ~2 million years ago (mya), the common ancestor between 1 and 2 is ~3 mya, and the common ancestor between 1,2, and 3 is ~6 mya. We expect this model to result in an intermediate level of ILS.

```{r input sample Data}
speciesTree <- read_speciesTree("tutorial/intro_sim_example/sampleSpeciesTree.nwk")
quiblOutput <- read_csv_quibl("tutorial/intro_sim_example/null_1000000_0.2.quibl")
originalTrees <- read.tree("tutorial/intro_sim_example/null_1000000_0.2.trees")
```

## Examine the data

What does our data look like? To understand this, let's take a look at what we've simulated as the species tree.

```{r speciesTree}
plot(speciesTree)
```

Now, let's look at the QuIBL output

```{r viewOutput}
quiblOutput
```

To get familiar with our data, we'll walk through each column.

**triplet**

QuIBL examines each 3-species grouping in our data separately. But we have 4 species, so shouldn't there be (4 choose 3) = 4 different triplets? Why do we only have one (1_2_3)? This is because QuIBL assumes that we have a rooted tree, and in this case we have rooted our tree by fixing "4" as the outgroup. QuIBL discards all triplets that include the overall outgroup, since all loci are forced to have the same topology ("4" as the outgroup).

**outgroup**

The outgroup dictates the tree topology, as in three-taxon trees there is one outgroup and two ingroups. For example, when outgroup == 1, the tree topology is (1,(2,3)).

**C1**

The internal branch length in the ILS only model. By definition, this is 0.

**C2**

The internal branch length in the two-ditribution model. If the topology is concordant with the species tree (In this case, when the outgroup is Htel, see the tree), C2 is the time between the two coalescence events. If this topology is discordant with the species tree, C2 is the time between the introgression event and the common ancestor of all three species.

**mixprop2**

Under the two-ditribution model, the proportion of loci that have a history of introgression

**mixprop1**

Under the two-ditribution model, the proportion of loci that have a history of ILS

**lambda2Dist**

The population size parameter (theta/2) under the two-ditribution model

**lambda1Dist**

The population size parameter (theta/2) under the ILS only model

**BIC2Dist**

The Bayesian Information Criteria for the fit of the data to the two-ditribution model

**BIC1Dist**

The Bayesian Information Criteria for the fit of the data to the ILS only model

*We only accept the two-distribution model if BIC2Dist is at least 10 units lower than BIC1Dist*

**count**

The number of loci that have this topology.

## Get some big-picture results

In order to interpret the output, we'll do some simple transformaions and report out our top-line results. First, we need to know which of our topologies is concordant with the species tree, and which represent either ILS or introgression. We'll use the isSpeciesTree fuction from quiblR.

```{r assign species topology}
quiblOutput <- mutate(quiblOutput, isDiscordant=as.integer(! apply(quiblOutput, 1, isSpeciesTree, sTree=speciesTree)))
```

Next, we'll mark which of the topologies' 2-distribution model is a significantly better fit than the ILS only model, and we'll calculate the proportion of loci with a history of introgression for the full data

```{r getSignificant}
quiblOutput <- mutate(quiblOutput, isSignificant = as.numeric(apply(quiblOutput, 1, testSignificance, threshold=10)))
totalTrees <- sum(quiblOutput$count)/length(unique(quiblOutput$triplet))
quiblOutput <- mutate(quiblOutput,totalIntrogressionFraction=(mixprop2*count*isDiscordant)/totalTrees)
quiblOutput
```

So, what have we learned? For the big picture question of introgression, we're interested in whether there is significantly more support for the two-distribution (ILS+introgression) than the one-distribution model (ILS only). We see that one of our discordant topologies - outgroup=1, is both discordant and significant. We can then look at the inferred introgression fraction, which is ~14%. This is conservative compared to the simulated value of 20%.  

## Evaluating model fit - does it pass the smell test

OK, let's take a quick look under the hood at the data that QuIBL is using to generate this output. The only data we're actually using is the internal branch length of triplet gene tress, grouped by topology. We can extract this information from the original tree file with the function getPerLocusStats. This will take a few moments.

```{r getPerLocusStats}
perLocusStats <- getPerLocusStats(quiblOutput = quiblOutput, trip = "1_2_3", treeList = originalTrees, overallOut="4")
head(perLocusStats)
```

As we can see, perLocusStats is now a data frame that includes the triplet sub-tree, the outgroup, internal branch length, and introgression probability. Let's look at the internal branch lengths for our putative introgression topology, where "1" is the outgroup.

```{r plot tel BL, echo=FALSE}
speciesTopBL <- ggplot(data=subset(perLocusStats, out=="1"))+
  geom_histogram(aes(x=branchLength), fill="grey50", bins = 100)+
  xlim(0,0.1)
speciesTopBL
```
Next, we'll generate the distributions that QuIBL calculated based on this data. We'll get three distributions: The ILS only, ILS as a part of the 2-distribution mixture, and non-ILS as a part of the 2-distribution mixture.

```{r getDistributions}
introTop_ILSOnly <- getILSOnlyDist(0,0.1,subset(quiblOutput, outgroup=="1" & triplet=="1_2_3"))
introTop_ILSMix <- getILSMixtureDist(0,0.1,subset(quiblOutput, outgroup=="1" & triplet=="1_2_3"))
introTop_nonILSMix <- getNonILSMixtureDist(0,0.1,subset(quiblOutput, outgroup=="1" & triplet=="1_2_3"))
```

Now, we'll plot them over our data and see how they look. For the 2-distribution mixture, we'll plot each individual distribution as a dashed line, and the sum of the two as a solid line. The sum should hopefully match the data.

```{r plot branch lengths with distributions, echo=FALSE}
outgroup1_ILSOnlyDist <- ggplot(data=subset(perLocusStats, out=="1"))+
  geom_histogram(aes(x=branchLength), fill="grey50", col=NA, bins=125)+
  geom_line(data=introTop_ILSOnly,aes(x=x,y=y), alpha=0.7)+
  xlim(0,0.1)+
  labs(title = "ILS only")

outgroup1_MixDist <- ggplot(data=subset(perLocusStats, out=="1"))+
  geom_histogram(aes(x=branchLength), fill="grey50", col=NA, bins=125)+
  # geom_line(data=introTop_ILSMix,aes(x=x,y=y), lty=2, alpha=0.7)+
  # geom_line(data=introTop_nonILSMix,aes(x=x,y=y), lty=2, alpha=0.7)+
  geom_line(data=introTop_nonILSMix,aes(x=x,y=y+introTop_ILSMix$y), alpha=0.7)+
  xlim(0,0.1)+
  labs(title = "ILS, nonILS sum")

outgroup1_decomp <- ggplot(data=subset(perLocusStats, out=="1"))+
  geom_histogram(aes(x=branchLength), fill="grey50", col=NA, bins=125)+
  geom_line(data=introTop_ILSMix,aes(x=x,y=y), lty=2, alpha=0.7)+
  geom_line(data=introTop_nonILSMix,aes(x=x,y=y), lty=2, alpha=0.7)+
  # geom_line(data=introTop_nonILSMix,aes(x=x,y=y+speciesTop_ILSMix$y), alpha=0.7)+
  xlim(0,0.1)+
  labs(title = "ILS, nonILS decomposition")

ggarrange(outgroup1_ILSOnlyDist, outgroup1_MixDist,outgroup1_decomp,
          ncol = 1, nrow = 3)

```

Not perfect, but not bad! Clearly, the ILS only model is a poor fit for our data. We can tell there are two peaks in our data, not a simple exponential decay. Looking at the sum of the mixture model (which is what we expect to observe), we can see that the introgression distribution nicely fits the right side of our data, though the peak is slightly overestimated.

So, why are we off, even if the 2-distribution model is clearly better than the ILS only? It could be a number of reasons. First, we have a finite number of datapoints here, but we're fitting a continuous model. We've tried to illustrate this limitation by plotting our data as a histogram instead of a smoothed density distribution so you can see how blocky it is. Second, though the sequences were simulated, we did then estimate the gene tree branch lengths with PhyML. That introduces some error as well.

We can follow this up by looking at the distribution of branch lengths that we expect to only arise due to ILS. There are many fewer of these, but we can still see if the distribution looks reasonable.

```{r ILS topology branch lengths with distributions, echo=FALSE}
ILStop_ILSOnly <-  getILSOnlyDist(0,0.1,subset(quiblOutput, outgroup=="2" & triplet=="1_2_3"))

outgroup2_ILSOnlyDist <- ggplot(data=subset(perLocusStats, out=="2"))+
  geom_histogram(aes(x=branchLength), fill="grey50", col=NA, bins=30)+
  geom_line(data=ILStop_ILSOnly,aes(x=x,y=y), alpha=0.7)+
  xlim(0,0.1)+
  labs(title = "Outgroup=2; ILS only")

outgroup2_ILSOnlyDist
```


## Larger datasets
This was a relatively simple, compact example, but what happens when we are analyzing a broader clade? Let's load in some real data from Edelman et al 2019.

```{r input largeClade Data}
largeSpeciesTree <- read_speciesTree("tutorial/heliconius_full_example/fullHeliconiusSpeciesTree.txt")
largeQuiblOutput <- read_csv_quibl("tutorial/heliconius_full_example/heliconius_5kTrees.quibl.csv")
largeOriginalTrees <- read.tree("tutorial/heliconius_full_example/heliconius_5kTrees.nwk")
```


Again, we'll add our useful columns as above.

```{r format largeClade Data}
totalTrees <- sum(largeQuiblOutput$count)/length(unique(largeQuiblOutput$triplet))

largeQuiblOutput <- mutate(largeQuiblOutput,
                           isDiscordant = as.integer(! apply(largeQuiblOutput, 1, isSpeciesTree, sTree=largeSpeciesTree)),
                           isSignificant = as.integer(apply(largeQuiblOutput, 1, testSignificance, threshold=10)),
                           totalIntrogressionFraction=(mixprop2*count*isDiscordant)/totalTrees)
head(largeQuiblOutput)
```

Now, we have lots of results...60 rows in all. That's not quite as easy to make sense of as a data frame, so let's try to summarize the data. We'll use quiblR's getIntrogressionSummary function. This will return a data frame with the average introgression fraction for each pair of taxa. Specifically, it goes triplet by triplet, ignores topologies concordant with the species tree, and records mixprop2*count/total trees, and averages that value across all tests that include each pair of species.

```{r get correlations}
introgressionSummary <- getIntrogressionSummary(largeQuiblOutput,largeSpeciesTree)
#introgressionSummary$value <- as.numeric(ifelse(introgressionSummary$tax1==introgressionSummary$tax2,NA_integer_,introgressionSummary$value))
head(introgressionSummary)
```

We can now make a heatmap of these relationships.

```{r correlation heatmap}
summaryMatrix <- ggplot(data = introgressionSummary, aes(tax1, tax2, fill = value))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "white", high = "red", mid = "yellow",na.value = "grey50",
   midpoint = max(introgressionSummary$value)/2, limit = c(0,max(introgressionSummary$value)),
   name="Average introgression fraction") +
geom_abline(slope = 1, intercept=0)+
  geom_vline(xintercept=seq(1.5,nrow(introgressionSummary)+0.5,1), alpha=0.6)+
  geom_hline(yintercept=seq(1.5,nrow(introgressionSummary)+0.5,1), alpha=0.6)+
  labs(x="", y="")+
  #scale_x_discrete(position = "top") +
 theme(panel.grid = element_blank(),legend.position = "none")


#summaryMatrix

speciesTreeSubset <- ggtree(extractTripletTree(largeSpeciesTree, unique(introgressionSummary$tax1)))

speciesTreeSubset_down <- ggtree(extractTripletTree(largeSpeciesTree, unique(introgressionSummary$tax1)))+ coord_flip()

#speciesTreeSubset

ggarrange(  speciesTreeSubset, summaryMatrix,NULL, speciesTreeSubset_down,
          ncol = 2,nrow=2, heights=c(2,1), widths=c(1,2), align="hv",common.legend = TRUE)
```

It looks like we have the most evidence for introgression involving *H. hecalesia* (Hhsa) and *H. telesiphe* (Htel). Let's check out a triplet that would be informative for checking for introgression between these two. We'll use HeraRef_Hhsa_Htel, which estimates that when *H. erato* (HeraRef) is the outgroup, ~94% of all topologies arose via introgression (mixprop2), corresponding to an overall introgression fraction in the genome of ~38% (totalIntrogressionFraction).

```{r Hhsa_Htel_Hera summary}
subset(largeQuiblOutput, triplet=="HeraRef_Hhsa_Htel")
```

```{r Hhsa_Htel_Hera perLocus}
Hhsa_Htel_Hera_LocusStats <- getPerLocusStats(quiblOutput = largeQuiblOutput, trip = "HeraRef_Hhsa_Htel", treeList = largeOriginalTrees, overallOut="HmelRef")
head(Hhsa_Htel_Hera_LocusStats)
```
Next, we'll generate the distributions

```{r get Hhsa_Htel_Hera Distributions}
Hhsa_Htel_Hera_ILSOnly <- getILSOnlyDist(0,0.1,subset(largeQuiblOutput, outgroup=="Htel" & triplet=="HeraRef_Hhsa_Htel"))
Hhsa_Htel_Hera_ILSMix <- getILSMixtureDist(0,0.1,subset(largeQuiblOutput, outgroup=="Htel" & triplet=="HeraRef_Hhsa_Htel"))
Hhsa_Htel_Hera_nonILSMix <- getNonILSMixtureDist(0,0.1,subset(largeQuiblOutput, outgroup=="Htel" & triplet=="HeraRef_Hhsa_Htel"))
```

Now, we'll plot them over our data and see how they look

```{r plot Hhsa_Htel_Hera with distributions, echo=FALSE}
speciesILSOnlyDist <- ggplot(data=subset(Hhsa_Htel_Hera_LocusStats, out=="Htel"))+
  geom_histogram(aes(x=branchLength), fill="grey50", col=NA, bins=250)+
  geom_line(data=Hhsa_Htel_Hera_ILSOnly,aes(x=x,y=y), alpha=0.7)+
  xlim(0,0.1)+
  labs(title = "ILS only")

speciesMixDist <- ggplot(data=subset(Hhsa_Htel_Hera_LocusStats, out=="Htel"))+
  geom_histogram(aes(x=branchLength), fill="grey50", col=NA, bins=250)+
  geom_line(data=Hhsa_Htel_Hera_ILSMix,aes(x=x,y=y), lty=2, alpha=0.7)+
  geom_line(data=Hhsa_Htel_Hera_nonILSMix,aes(x=x,y=y), lty=2, alpha=0.7)+
  geom_line(data=Hhsa_Htel_Hera_nonILSMix,aes(x=x,y=y+Hhsa_Htel_Hera_ILSMix$y), alpha=0.7)+
  xlim(0,0.1)+
  labs(title = "ILS, nonILS mixture")

ggarrange(speciesILSOnlyDist, speciesMixDist,
          ncol = 2, nrow = 1)
```

OK, that looks pretty good! We can be confident in our estimated introgression fraction.
