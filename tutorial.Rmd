---
title: "QuIBL analysis tutorial"
author: "Nate Edelman"
date: "2/25/2020"
output: html_document
---

```{r global_options, message=FALSE, warning=FALSE, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8, echo=TRUE, warning=FALSE)
```

This is a tutorial for how to analyze output from the Quantifying Introgression via Branch Lengths software. For more details on QuIBL see <http://github.com/michaelmiyagi/QuIBL>.

First, we'll set up our environment. 
```{r load packages}
library("quiblR")
library("ggplot2")
library("ape")
suppressMessages(library("ggpubr"))
suppressMessages(library("dplyr"))

```

## Load the data

Now, we'll import the data generated by our simple, 4-taxon QuIBL run.

```{r input sample Data}
speciesTree <- read_speciesTree("tutorial/intro_sim_example/sampleSpeciesTree.nwk")
quiblOutput <- read_csv_quibl("tutorial/intro_sim_example/null_1000000_0.2.quibl")
originalTrees <- read.tree("tutorial/intro_sim_example/null_1000000_0.2.trees")
```

## Examine the data

What does our data look like? To understand this, let's take a look at what we've independently inferred to be the species tree.

```{r speciesTree}
plot(speciesTree)
```

Now, let's look at the QuIBL output

```{r viewOutput}
quiblOutput
```

To get familiar with our data, we'll walk through each column.

**triplet**

QuIBL examines each 3-species grouping in our data separately. But we have 4 species, so shouldn't there be (4 choose 3) = 4 different triplets? Why do we only have one (1_2_3)? This is because QuIBL assumes that we have a rooted tree, and in this case we have rooted our tree by fixing "4" as the outgroup. QuIBL discards all triplets that include the overall outgroup, since all loci are forced to have the same topology ("4" as the outgroup).

**outgroup**

The outgroup dictates the tree topology, as in three-taxon trees there is one outgroup and two ingroups. For example, when outgroup == 1, the tree topology is (1,(2,3)).

**C1**

The internal branch length in the ILS only model. By definition, this is 0.

**C2**

The internal branch length in the two-ditribution model. If the topology is concordant with the species tree (In this case, when the outgroup is Htel, see the tree), C2 is the time between the two coalescence events. If this topology is discordant with the species tree, C2 is the time between the introgression event and the common ancestor of all three species.

**mixprop2**

Under the two-ditribution model, the proportion of loci that have a history of introgression 

**mixprop1**

Under the two-ditribution model, the proportion of loci that have a history of ILS 

**lambda2Dist**

The population size parameter (theta/2) under the two-ditribution model

**lambda1Dist**

The population size parameter (theta/2) under the ILS only model

**BIC2Dist**

The Bayesian Information Criteria for the fit of the data to the two-ditribution model

**BIC1Dist**

The Bayesian Information Criteria for the fit of the data to the ILS only model

*We only accept the two-distribution model if BIC2Dist is at least 10 units lower than BIC1Dist*

**count**

The number of loci that have this topology. 

## Get some big-picture results

In order to interpret the output, we'll do some simple transformaions and report out our top-line results. First, we need to know which of our topologies is concordant with the species tree, and which represent either ILS or introgression. We'll use the isSpeciesTree fuction from quiblR.

```{r assign species topology}
quiblOutput <- mutate(quiblOutput, isDiscordant=as.integer(! apply(quiblOutput, 1, isSpeciesTree, sTree=speciesTree)))
```

Next, we'll mark which of the topologies' 2-distribution model is a significantly better fit than the ILS only model, and if so we'll calculate the proportion of loci with a history of introgression for the full data for this triplet

```{r getSignificant}
quiblOutput <- mutate(quiblOutput, isSignificant = as.numeric(apply(quiblOutput, 1, testSignificance, threshold=10)))
totalTrees <- sum(quiblOutput$count)/length(unique(quiblOutput$triplet))
quiblOutput <- mutate(quiblOutput,totalIntrogressionFraction=(mixprop2*count*isDiscordant)/totalTrees)
quiblOutput
```

So, what have we learned? Well, since this is all simulated data with no introgression, it's not very exciting. We see that almost all of the gene trees have the condordant topology and within that concordant topology practically no gene trees experienced ILS (see mixprop1). Still, we can 

## Evaluating model fit - does it pass the smell test

OK, let's take a quick look under the hood at the data that QuIBL is using to generate this output. The only data we're actually using is the internal branch length of triplet gene tress, grouped by topology. We can extract this information from the original tree file with the function getPerLocusStats. This will take a bit of time.

```{r getPerLocusStats}
perLocusStats <- getPerLocusStats(quiblOutput = quiblOutput, trip = "1_2_3", treeList = originalTrees, overallOut="4")
head(perLocusStats)
```

As we can see, perLocusStats is now a data frame that includes the triplet sub-tree, the outgroup, internal branch length, and introgression probability. Let's look at the species tree topology first, which is the one where "3" is the outgroup.

```{r plot tel BL, echo=FALSE}
speciesTopBL <- ggplot(data=subset(perLocusStats, out=="3"))+
  geom_histogram(aes(x=branchLength), fill="grey50", bins = 100)+
  xlim(0,0.1)
speciesTopBL
```
Next, we'll generate the distributions that QuIBL calculated based on this data. We'll get three distributions: The ILS only, ILS as a part of the 2-distribution mixture, and non-ILS as a part of the 2-distribution mixture.

```{r getDistributions}
speciesTop_ILSOnly <- getILSOnlyDist(0,0.1,subset(quiblOutput, outgroup=="3" & triplet=="1_2_3"))
speciesTop_ILSMix <- getILSMixtureDist(0,0.1,subset(quiblOutput, outgroup=="3" & triplet=="1_2_3"))
speciesTop_nonILSMix <- getNonILSMixtureDist(0,0.1,subset(quiblOutput, outgroup=="3" & triplet=="1_2_3"))
```

Now, we'll plot them over our smoothed data and see how they look

```{r plot tel with distributions, echo=FALSE}
speciesILSOnlyDist <- ggplot(data=subset(perLocusStats, out=="3"))+
  geom_density(aes(x=branchLength), fill="grey50", col=NA, bins=250)+
  geom_line(data=speciesTop_ILSOnly,aes(x=x,y=y), alpha=0.7)+
  xlim(0,0.1)+
  labs(title = "ILS only")

speciesMixDist <- ggplot(data=subset(perLocusStats, out=="3"))+
  geom_density(aes(x=branchLength), fill="grey50", col=NA, bins=250)+
  geom_line(data=speciesTop_ILSMix,aes(x=x,y=y), lty=2, alpha=0.7)+
  geom_line(data=speciesTop_nonILSMix,aes(x=x,y=y), lty=2, alpha=0.7)+
  geom_line(data=speciesTop_nonILSMix,aes(x=x,y=y+speciesTop_ILSMix$y), alpha=0.7)+
  xlim(0,0.1)+
  labs(title = "ILS, nonILS mixture")

ggarrange(speciesILSOnlyDist, speciesMixDist,
          ncol = 2, nrow = 1)

```

As we can see, 









## Larger datasets
This was a very simple, compact example, but what happens when we are analyzing a broader clade?

```{r input largeClade Data}
largeSpeciesTree <- read_speciesTree("tutorial/heliconius_full_example/fullHeliconiusSpeciesTree.txt")
largeQuiblOutput <- read_csv_quibl("tutorial/heliconius_full_example/heliconius_5kTrees.quibl.csv")
largeOriginalTrees <- read.tree("tutorial/heliconius_full_example/heliconius_5kTrees.nwk")
```


Again, we'll add our useful columns as above.

```{r format largeClade Data}
totalTrees <- sum(largeQuiblOutput$count)/length(unique(largeQuiblOutput$triplet))

largeQuiblOutput <- mutate(largeQuiblOutput, 
                           isDiscordant = as.integer(! apply(largeQuiblOutput, 1, isSpeciesTree, sTree=largeSpeciesTree)), 
                           isSignificant = as.integer(apply(largeQuiblOutput, 1, testSignificance, threshold=10)),
                           totalIntrogressionFraction=(mixprop2*count*isDiscordant)/totalTrees)
head(largeQuiblOutput)
```
Let's take a look at one of our triplets

```{r Hhsa_Htel_Hera perLocus}
Hsa_Htel_Hera_LocusStats <- getPerLocusStats(quiblOutput = largeQuiblOutput, trip = "HeraRef_Hhsa_Htel", treeList = largeOriginalTrees, overallOut="HmelRef")
head(Hsa_Htel_Hera_LocusStats)
```
Next, we'll generate the distributions 

```{r get Hhsa_Htel_Hera Distributions}
Hsa_Htel_Hera_ILSOnly <- getILSOnlyDist(0,0.1,subset(largeQuiblOutput, outgroup=="Htel" & triplet=="HeraRef_Hhsa_Htel"))
Hsa_Htel_Hera_ILSMix <- getILSMixtureDist(0,0.1,subset(largeQuiblOutput, outgroup=="Htel" & triplet=="HeraRef_Hhsa_Htel"))
Hsa_Htel_Hera_nonILSMix <- getNonILSMixtureDist(0,0.1,subset(largeQuiblOutput, outgroup=="Htel" & triplet=="HeraRef_Hhsa_Htel"))
```

Now, we'll plot them over our smoothed data and see how they look

```{r plot Hhsa_Htel_Hera with distributions, echo=FALSE}
speciesILSOnlyDist <- ggplot(data=subset(Hsa_Htel_Hera_LocusStats, out=="Htel"))+
  geom_density(aes(x=branchLength), fill="grey50", col=NA, bins=250)+
  geom_line(data=Hsa_Htel_Hera_ILSOnly,aes(x=x,y=y), alpha=0.7)+
  xlim(0,0.1)+
  labs(title = "ILS only")

speciesMixDist <- ggplot(data=subset(Hsa_Htel_Hera_LocusStats, out=="Htel"))+
  geom_density(aes(x=branchLength), fill="grey50", col=NA, bins=250)+
  geom_line(data=Hsa_Htel_Hera_ILSMix,aes(x=x,y=y), lty=2, alpha=0.7)+
  geom_line(data=Hsa_Htel_Hera_nonILSMix,aes(x=x,y=y), lty=2, alpha=0.7)+
  geom_line(data=Hsa_Htel_Hera_nonILSMix,aes(x=x,y=y+Hsa_Htel_Hera_ILSMix$y), alpha=0.7)+
  xlim(0,0.1)+
  labs(title = "ILS, nonILS mixture")

ggarrange(speciesILSOnlyDist, speciesMixDist,
          ncol = 2, nrow = 1)
```
